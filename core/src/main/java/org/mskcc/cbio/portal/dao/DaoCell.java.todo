/* LICENSE_TBD */

package org.mskcc.cbio.portal.dao;

import org.mskcc.cbio.portal.model.CanonicalCell;
import org.mskcc.cbio.portal.util.ProgressMonitor;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Data Access Object to Cell Table.
 * For faster access, consider using DaoCellOptimized.
 *
 * @author Ethan Cerami.
 */
final class DaoCell {

    /**
     * Private Constructor to enforce Singleton Pattern.
     */
    private DaoCell() {
    }
    
    private static int fakeCellEntityId = 0;
    private static synchronized int getNextFakeCellEntityId() throws DaoException {
        while (getCell(--fakeCellEntityId)!=null);
        return fakeCellEntityId;
    }
    
    public static synchronized int addCellWithoutCellEntityId(CanonicalCell cell) throws DaoException {
        CanonicalCell existingCell = getCell(cell.getInputCellTypeNameAllCaps());
        cell.setCellEntityId(existingCell==null?getNextFakeCellEntityId():existingCell.getCellEntityId());
        return addOrUpdateCell(cell);
    }

    /**
     * Update Cell Record of cellEntityId in the Database 
     */
    public static int updateCell(CanonicalCell cell) throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        boolean setBulkLoadAtEnd = false;
        try {
            //this method only works well with bulk load off, especially 
            //when it is called in a process that may update a cell more than once
            //(e.g. the ImportCellData updates some of the fields based on one 
            // input file and other fields based on another input file):
            setBulkLoadAtEnd = MySQLbulkLoader.isBulkLoad();
            MySQLbulkLoader.bulkLoadOff();
            
            int rows = 0;
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement
                ("UPDATE IM_cell SET `CELLPEDIA_CELL_TYPE_NAME`=?, `TYPE`=?,`ORGAN`=?,`LENGTH`=? `CELLPEDIA_CELL_TYPE_ID`=? WHERE CELL_ENTITY_ID=?");
            pstmt.setString(1, cell.getInputCellTypeNameAllCaps());
            pstmt.setString(2, cell.getType());
            pstmt.setString(3, cell.getOrgan());
            pstmt.setInt(4, cell.getLength());
            pstmt.setLong(5, cell.getInputCellTypeId());
            pstmt.setLong(6, cell.getCellEntityId());
            rows += pstmt.executeUpdate();
            if (rows != 1) {
                ProgressMonitor.logWarning("No change for " + cell.getInputCellTypeId() + " " + cell.getInputCellTypeNameAllCaps() + " " + cell.getCellEntityId() + "? Code " + rows);
            }

            return rows;
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            if (setBulkLoadAtEnd) {
                //reset to original state:
                MySQLbulkLoader.bulkLoadOn();
            }   
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
        
}
    
    /**
     * Adds a new Cell Record to the Database OR updates the given cell object
     * with the cellEntityId found in the DB for this cell.
     * If it is a new cell, it will cellrate a new cell entity id and
     * update the given CanonicalCell with the cellrated (in the range of 1,000,000,000-2,000,000,000)
     * cellEntityId. 
     * 
     * Adds a new Cell Record to the Database.
     *
     * @param cell Canonical Cell Object.
     * @return number of records successfully added.
     * @throws DaoException Database Error.
     */
    public static int addOrUpdateCell(CanonicalCell cell) throws DaoException {

        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            int rows = 0;
            CanonicalCell existingCell = getCell(cell.getCellEntityId());
            if (existingCell == null) {
            	//new cell, so add cell entity first:
            	int cellEntityId = DaoCellEntity.addNewCellEntity(DaoCellEntity.EntityTypes.GENE);
            	//update the Canonical cell as well:
            	cell.setCellEntityId(cellEntityId); //TODO can we find a better way for this, to avoid this side effect? 
            	//add cell, referring to this cell entity
            	con = JdbcUtil.getDbConnection(DaoCell.class);
            	pstmt = con.prepareStatement
                        ("INSERT INTO IM_cell (`CELL_ENTITY_ID`, `CELLPEDIA_CELL_TYPE_ID`,`CELLPEDIA_CELL_TYPE_NAME`,`TYPE`,`ORGAN`,`LENGTH`) "
                                + "VALUES (?,?,?,?,?,?)");
            	pstmt.setInt(1, cellEntityId);
              pstmt.setLong(2, cell.getInputCellTypeId());
              pstmt.setString(3, cell.getInputCellTypeNameAllCaps());
              pstmt.setString(4, cell.getType());
              pstmt.setString(5, cell.getOrgan());
              pstmt.setInt(6, cell.getLength());
              rows += pstmt.executeUpdate();
            } else {
            	if (cell.getCellEntityId() == -1) {
	            	//update the Canonical cell  //TODO can we find a better way for this, to avoid this side effect?
	            	cell.setCellEntityId(existingCell.getCellEntityId());
            	} else {
            		//check correctness...normally this error would not occur unless there is an invalid use of CanonicalCell
            		if (cell.getCellEntityId() != existingCell.getCellEntityId())
            			throw new RuntimeException("Unexpected error. Invalid cell entity id for cell: " + cell.getInputCellTypeNameAllCaps() + " (" + cell.getCellEntityId() + ")"); 
            	} 
            }	

            // rows += addCellAliases(cell);  // cell alias is on TODO list

            return rows;
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }

    /**
     * Gets the Cell with the Specified .
     * For faster access, consider using DaoCellOptimized (TODO).
     *
     * @param inputCellTypeId
     * @return CanonicalCell Object.
     * @throws DaoException Database Error.
     */
    private static CanonicalCell getCell(long cellEntityId) throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement
                    ("SELECT * FROM IM_cell WHERE CELL_ENTITY_ID = ?");
            pstmt.setLong(1, cellEntityId);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                return extractCell(rs);
            } else {
                return null;
            }
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }
    
    /**
     * Gets all Cells in the Database.
     *
     * @return ArrayList of Canonical Cells.
     * @throws DaoException Database Error.
     */
    public static ArrayList<CanonicalCell> getAllCells() throws DaoException {
        Set<String> aliases = null; //TODO Alias place holder
        // Map<Long,Set<String>> mapAliases = getAllAliases(); //TODO Alias
        ArrayList<CanonicalCell> cellList = new ArrayList<CanonicalCell>();
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement
                    ("SELECT * FROM IM_cell");
            rs = pstmt.executeQuery();
            while (rs.next()) {
            	int cellEntityId = rs.getInt("CELL_ENTITY_ID");
                long inputCellTypeId = rs.getInt("CELLPEDIA_CELL_TYPE_ID");
                //Set<String> aliases = mapAliases.get(inputCellTypeId); //TODO Alias
                CanonicalCell cell = new CanonicalCell(cellEntityId, inputCellTypeId,
                        rs.getString("CELLPEDIA_CELL_TYPE_NAME"), aliases);
                cell.setOrgan(rs.getString("ORGAN"));
                cell.setLength(rs.getInt("LENGTH"));
                cell.setType(rs.getString("TYPE"));
                cellList.add(cell);
            }
            return cellList;
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }

    /**
     * Gets the Cell with the Specified inputCellTypeName.
     * For faster access, consider using DaoCellOptimized. //TODO
     *
     * @param inputCellTypeName HUGO Cell Symbol.
     * @return Canonical Cell Object.
     * @throws DaoException Database Error.
     */
    private static CanonicalCell getCell(String inputCellTypeName) throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement
                    ("SELECT * FROM IM_cell WHERE CELLPEDIA_CELL_TYPE_NAME = ?");
            pstmt.setString(1, inputCellTypeName);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                return extractCell(rs);
            } else {
                return null;
            }
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }
    
    private static CanonicalCell extractCell(ResultSet rs) throws SQLException, DaoException {
    	int cellEntityId = rs.getInt("CELL_ENTITY_ID");
    	long inputCellTypeId = rs.getInt("CELLPEDIA_CELL_TYPE_ID");
      Set<String> aliases = null; //TODO Alias place holder
      // Set<String> aliases = getAliases(inputCellTypeId);  // TODO Alias
      CanonicalCell cell = new CanonicalCell(cellEntityId, inputCellTypeId,
                    rs.getString("CELLPEDIA_CELL_TYPE_NAME"), aliases);
      cell.setType(rs.getString("TYPE"));
      cell.setOrgan(rs.getString("ORGAN"));
      cell.setLength(rs.getInt("LENGTH"));
            
      return cell;
    }

    /**
     * Gets the Number of Cell Records in the Database.
     *
     * @return number of cell records.
     * @throws DaoException Database Error.
     */
    public static int getCount() throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement
                    ("SELECT COUNT(*) FROM IM_cell");
            rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            }
            return 0;
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }
    
    /**
     * Deletes the Cell Records that has the inputCellTypeId in the Database.
     * 
     * @param inputCellTypeId 
     */
    public static void deleteCell(long inputCellTypeId) throws DaoException {
      // deleteCellAlias(inputCellTypeId);  //TODO Alias
        
    	Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement("DELETE FROM IM_cell WHERE CELLPEDIA_CELL_TYPE_ID=?");
            pstmt.setLong(1, inputCellTypeId);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }

    /**
     * Deletes all Cell Records in the Database.
     *
     * @throws DaoException Database Error.
     * 
     * @deprecated only used by deprecated code, so deprecating this as well.
     */
    public static void deleteAllRecords() throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            JdbcUtil.disableForeignKeyCheck(con);
            pstmt = con.prepareStatement("TRUNCATE TABLE IM_cell");
            pstmt.executeUpdate();
            JdbcUtil.enableForeignKeyCheck(con);
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
        //deleteAllAliasRecords(); //TODO Alias
    }
    
    /**  BEGIN OF TODO
     * Add cell_alias records.
     * @param cell Canonical Cell Object.
     * @return number of records successfully added.
     * @throws DaoException Database Error.

    public static int addCellAliases(CanonicalCell cell)  throws DaoException {
        if (MySQLbulkLoader.isBulkLoad()) {
            //  write to the temp file maintained by the MySQLbulkLoader
            Set<String> aliases = cell.getAliases();
            for (String alias : aliases) {
                MySQLbulkLoader.getMySQLbulkLoader("cell_alias").insertRecord(
                        Long.toString(cell.getInputCellTypeId()),
                        alias);

            }
            // return 1 because normal insert will return 1 if no error occurs
            return 1;
        }
        
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            Set<String> aliases = cell.getAliases();
            Set<String> existingAliases = getAliases(cell.getInputCellTypeId());
            int rows = 0;
            for (String alias : aliases) {
                if (!existingAliases.contains(alias)) {
                    pstmt = con.prepareStatement("INSERT INTO IM_cell_alias "
                            + "(`CELLPEDIA_CELL_TYPE_ID`,`GENE_ALIAS`) VALUES (?,?)");
                    pstmt.setLong(1, cell.getInputCellTypeId());
                    pstmt.setString(2, alias);
                    rows += pstmt.executeUpdate();
                }
            }

            return rows;
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }


     //* Gets aliases for all cells.
     //* @return map from entrez cell id to a set of aliases.
     //* @throws DaoException Database Error.

    private static Set<String> getAliases(long inputCellTypeId) throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement
                    ("SELECT * FROM IM_cell_alias WHERE CELLPEDIA_CELL_TYPE_ID = ?");
            pstmt.setLong(1, inputCellTypeId);
            rs = pstmt.executeQuery();
            Set<String> aliases = new HashSet<String>();
            while (rs.next()) {
                aliases.add(rs.getString("GENE_ALIAS"));
            }
            return aliases;
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }
    
    private static Map<Long,Set<String>> getAllAliases() throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement
                    ("SELECT * FROM IM_cell_alias");
            rs = pstmt.executeQuery();
            Map<Long,Set<String>> map = new HashMap<Long,Set<String>>();
            while (rs.next()) {
                Long entrez = rs.getLong("CELLPEDIA_CELL_TYPE_ID");
                Set<String> aliases = map.get(entrez);
                if (aliases==null) {
                    aliases = new HashSet<String>();
                    map.put(entrez, aliases);
                }
                aliases.add(rs.getString("GENE_ALIAS"));
            }
            return map;
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }

     // Deletes the Cell Alias Record(s) that has/have the Entrez Cell ID in the Database.
     // 
     // @param inputCellTypeId 

    public static void deleteCellAlias(long inputCellTypeId) throws DaoException {
        Connection con = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            con = JdbcUtil.getDbConnection(DaoCell.class);
            pstmt = con.prepareStatement("DELETE FROM IM_cell_alias WHERE CELLPEDIA_CELL_TYPE_ID=?");
            pstmt.setLong(1, inputCellTypeId);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            throw new DaoException(e);
        } finally {
            JdbcUtil.closeAll(DaoCell.class, con, pstmt, rs);
        }
    }
     END */
    
}
